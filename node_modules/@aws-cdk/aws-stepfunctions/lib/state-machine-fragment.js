"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cdk = require("@aws-cdk/core");
const chain_1 = require("./chain");
const parallel_1 = require("./states/parallel");
const state_1 = require("./states/state");
/**
 * Base class for reusable state machine fragments
 */
class StateMachineFragment extends cdk.Construct {
    get id() {
        return this.node.id;
    }
    /**
     * Prefix the IDs of all states in this state machine fragment
     *
     * Use this to avoid multiple copies of the state machine all having the
     * same state IDs.
     *
     * @param prefix The prefix to add. Will use construct ID by default.
     */
    prefixStates(prefix) {
        state_1.State.prefixStates(this, prefix || `${this.id}: `);
        return this;
    }
    /**
     * Wrap all states in this state machine fragment up into a single state.
     *
     * This can be used to add retry or error handling onto this state
     * machine fragment.
     *
     * Be aware that this changes the result of the inner state machine
     * to be an array with the result of the state machine in it. Adjust
     * your paths accordingly. For example, change 'outputPath' to
     * '$[0]'.
     */
    toSingleState(options = {}) {
        const stateId = options.stateId || this.id;
        this.prefixStates(options.prefixStates || `${stateId}: `);
        return new parallel_1.Parallel(this, stateId, options).branch(this);
    }
    /**
     * Continue normal execution with the given state
     */
    next(next) {
        return chain_1.Chain.start(this).next(next);
    }
}
exports.StateMachineFragment = StateMachineFragment;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtbWFjaGluZS1mcmFnbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInN0YXRlLW1hY2hpbmUtZnJhZ21lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBc0M7QUFDdEMsbUNBQWdDO0FBQ2hDLGdEQUE0RDtBQUM1RCwwQ0FBdUM7QUFHdkM7O0dBRUc7QUFDSCxNQUFzQixvQkFBcUIsU0FBUSxHQUFHLENBQUMsU0FBUztJQVc1RCxJQUFXLEVBQUU7UUFDVCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksWUFBWSxDQUFDLE1BQWU7UUFDL0IsYUFBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbkQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxhQUFhLENBQUMsVUFBOEIsRUFBRTtRQUNqRCxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsWUFBWSxJQUFJLEdBQUcsT0FBTyxJQUFJLENBQUMsQ0FBQztRQUUxRCxPQUFPLElBQUksbUJBQVEsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxJQUFJLENBQUMsSUFBZ0I7UUFDeEIsT0FBTyxhQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBQ0o7QUFwREQsb0RBb0RDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNkayA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2NvcmUnKTtcbmltcG9ydCB7IENoYWluIH0gZnJvbSAnLi9jaGFpbic7XG5pbXBvcnQgeyBQYXJhbGxlbCwgUGFyYWxsZWxQcm9wcyB9IGZyb20gJy4vc3RhdGVzL3BhcmFsbGVsJztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnLi9zdGF0ZXMvc3RhdGUnO1xuaW1wb3J0IHsgSUNoYWluYWJsZSwgSU5leHRhYmxlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciByZXVzYWJsZSBzdGF0ZSBtYWNoaW5lIGZyYWdtZW50c1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RhdGVNYWNoaW5lRnJhZ21lbnQgZXh0ZW5kcyBjZGsuQ29uc3RydWN0IGltcGxlbWVudHMgSUNoYWluYWJsZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IHN0YXRlIG9mIHRoaXMgc3RhdGUgbWFjaGluZSBmcmFnbWVudFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBzdGFydFN0YXRlOiBTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGF0ZXMgdG8gY2hhaW4gb250byBpZiB0aGlzIGZyYWdtZW50IGlzIHVzZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZW5kU3RhdGVzOiBJTmV4dGFibGVbXTtcblxuICAgIHB1YmxpYyBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlZml4IHRoZSBJRHMgb2YgYWxsIHN0YXRlcyBpbiB0aGlzIHN0YXRlIG1hY2hpbmUgZnJhZ21lbnRcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHRvIGF2b2lkIG11bHRpcGxlIGNvcGllcyBvZiB0aGUgc3RhdGUgbWFjaGluZSBhbGwgaGF2aW5nIHRoZVxuICAgICAqIHNhbWUgc3RhdGUgSURzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZC4gV2lsbCB1c2UgY29uc3RydWN0IElEIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgcHVibGljIHByZWZpeFN0YXRlcyhwcmVmaXg/OiBzdHJpbmcpOiBTdGF0ZU1hY2hpbmVGcmFnbWVudCB7XG4gICAgICAgIFN0YXRlLnByZWZpeFN0YXRlcyh0aGlzLCBwcmVmaXggfHwgYCR7dGhpcy5pZH06IGApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcmFwIGFsbCBzdGF0ZXMgaW4gdGhpcyBzdGF0ZSBtYWNoaW5lIGZyYWdtZW50IHVwIGludG8gYSBzaW5nbGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkZCByZXRyeSBvciBlcnJvciBoYW5kbGluZyBvbnRvIHRoaXMgc3RhdGVcbiAgICAgKiBtYWNoaW5lIGZyYWdtZW50LlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHJlc3VsdCBvZiB0aGUgaW5uZXIgc3RhdGUgbWFjaGluZVxuICAgICAqIHRvIGJlIGFuIGFycmF5IHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgc3RhdGUgbWFjaGluZSBpbiBpdC4gQWRqdXN0XG4gICAgICogeW91ciBwYXRocyBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGNoYW5nZSAnb3V0cHV0UGF0aCcgdG9cbiAgICAgKiAnJFswXScuXG4gICAgICovXG4gICAgcHVibGljIHRvU2luZ2xlU3RhdGUob3B0aW9uczogU2luZ2xlU3RhdGVPcHRpb25zID0ge30pOiBQYXJhbGxlbCB7XG4gICAgICAgIGNvbnN0IHN0YXRlSWQgPSBvcHRpb25zLnN0YXRlSWQgfHwgdGhpcy5pZDtcbiAgICAgICAgdGhpcy5wcmVmaXhTdGF0ZXMob3B0aW9ucy5wcmVmaXhTdGF0ZXMgfHwgYCR7c3RhdGVJZH06IGApO1xuXG4gICAgICAgIHJldHVybiBuZXcgUGFyYWxsZWwodGhpcywgc3RhdGVJZCwgb3B0aW9ucykuYnJhbmNoKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnRpbnVlIG5vcm1hbCBleGVjdXRpb24gd2l0aCB0aGUgZ2l2ZW4gc3RhdGVcbiAgICAgKi9cbiAgICBwdWJsaWMgbmV4dChuZXh0OiBJQ2hhaW5hYmxlKSB7XG4gICAgICAgIHJldHVybiBDaGFpbi5zdGFydCh0aGlzKS5uZXh0KG5leHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjcmVhdGluZyBhIHNpbmdsZSBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpbmdsZVN0YXRlT3B0aW9ucyBleHRlbmRzIFBhcmFsbGVsUHJvcHMge1xuICAgIC8qKlxuICAgICAqIElEIG9mIG5ld2x5IGNyZWF0ZWQgY29udGFpbmluZyBzdGF0ZVxuICAgICAqXG4gICAgICogQGRlZmF1bHQgQ29uc3RydWN0IElEIG9mIHRoZSBTdGF0ZU1hY2hpbmVGcmFnbWVudFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHN0YXRlSWQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgdG8gcHJlZml4IGFsbCBzdGF0ZUlkcyBpbiB0aGUgc3RhdGUgbWFjaGluZSB3aXRoXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBzdGF0ZUlkXG4gICAgICovXG4gICAgcmVhZG9ubHkgcHJlZml4U3RhdGVzPzogc3RyaW5nO1xufSJdfQ==